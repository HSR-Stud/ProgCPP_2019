\newpage
\section{Klassenkonzept}
	\subsection{Begriff der Klasse}
		\begin{compactitem}
			\item Eine Klasse ist eine Struktur (eine Struktur besteht nur aus Daten), die mit den 	Funktionen, welche auf diesen Daten arbeiten, erweitert wurde.
			\item Eine Klasse ist also eine Struktur, welche die Daten und die Funktionen auf diesen Daten in ein syntaktisches Konstrukt packt.
			\item Die Klasse ist die Umsetzung der Datenkapsel.
			\item Eine Klassendeklaration ist eine Typendefinition. Die Variablen einer Klasse
			werden als Objekte bezeichnet.
		\end{compactitem}
	\begin{minipage}[t]{10cm}
		\subsection{UML ist...}
			\begin{compactitem}
				\item ... die Abkürzung für {\bf U}nified {\bf M}odelling {\bf L}anguage
				\item ... eine graphische Modellierungssprache
				\item ... ein fortlaufendes (objektorientiertes) Modellierungskonzept für alle Software-Entwicklungsphasen (Ziel der UML)
				\item ... der Standard für Softwaremodellierung
				\item ... (programmier-)sprachunabhängig
				\item ... {\bf kein} Softwareprozess-Modell
				\item ... {\bf kein} Lebenszyklusmodell
				\item ... {\bf keine} Programmiersprache
				\item ... {\bf nicht} ohne Redundanz (es gibt oft mehrere Möglichkeiten, etwas zu modellieren)
				\item ... {\bf kein} Softwaretool
			\end{compactitem}
	\end{minipage}	
	\hspace*{0.5cm}
	\begin{minipage}[t]{8 cm}
		\subsection{UML-Notation einer Klasse}
			\begin{center}
				\begin{tikzpicture}
					\begin{class}[text width=4cm]{ClassName}{0 ,0}
						\attribute {-attribute1: int = 0}
						\attribute {-attribute2: int = 0}
						\operation {+method1()}
						\operation {+method2()}
					\end{class}
				\end{tikzpicture}
			\end{center}
			\begin{compactitem}
				\item Eine Klasse ist der Bauplan für Objekte.
				\item Eine Klasse besteht aus Daten (Attribute) und den Funktionen (Methoden) auf diesen Daten.
				\item Sichtbarkeit: 
				\begin{compactitem}
					\item \lc{+} : \lc{public}
					\item \lc{-} : \lc{private}
					\item \lc{\#} : \lc{protected}
				\end{compactitem}
			\end{compactitem}
	\end{minipage} \\
	
	\begin{minipage}[t]{8 cm}	
		\subsection{Üblicher Aufbau einer Klassensyntax}
			\lstinputlisting{code/klassenschnittstelle.cpp} 
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{10 cm}		
			\subsubsection{Zugriffsschutz}
			\begin{compactitem}
				\item \lc{public} - Elemente können innerhalb und von ausserhalb der Klasse
				angesprochen werden.
					\begin{compactitem}
						\item fast alle Methoden sind \lc{public}
						\item Attribute sollen nie \lc{public} sein
					\end{compactitem}
				\item \lc{protected} - Elemente können von innerhalb der Klasse und von abgeleiteten
				Klassen angesprochen werden.
					\begin{compactitem}
						\item nur sparsam einsetzen!
					\end{compactitem}
				\item \lc{private} - Elemente können nur innerhalb der Klasse angesprochen werden.
					\begin{compactitem}
						\item grundsätzlich für alle Attribute und für einzelne (lokale) Methoden
					\end{compactitem}
			\end{compactitem}
	\end{minipage} \\
	
	\begin{minipage}[t]{8 cm}
		\subsubsection{Operationen einer Klasse}
			Operationen eine Klasse (= Funktionen, die im Klassenrumpf definiert sind) werden als
			Elementfunktionen oder Methoden bezeichnet.	Üblicherweise beginnen Elementfunktionen mit einem Kleinbuchstaben und werden in camelCase (mixedCase) notiert.	
			\lc{isEmpty();}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{10 cm}	
		\subsubsection{Information Hiding}
			\begin{compactitem}
				\item Klassen exportieren generell ausschliesslich Methoden. Alle Daten sind im Innern (private-Abschnitt) verborgen, der Zugriff erfolgt über die so genannten Elementfunktionen.
				\item Jede Klasse besteht damit aus zwei Dateien, der Schnittstellendatei (\lc{.h}) und	der Implementierungsdatei (\lc{.cpp}).
			\end{compactitem}
	\end{minipage}	
	
			\paragraph{$friend$-Elemente}
				\begin{compactitem}
					\item \lc{friend} - Jede Klasse kann andere Klassen oder Funktionen zum Freund	erklären. Dadurch werden die Zugriffsregeln durchbrochen.
					\item Jeder \lc{friend} darf auf alle Elemente der Klasse zugreifen.
					\item \lc{friend} ist eine \lc{C++} - Spezialität, welche die meisten anderen Programmiersprachen (z.B. \lc{Java}) nicht anbieten.
					\item \lc{friends}, insbesondere \lc{friend}-Klassen, können ein Anzeichen für schlechtes Design sein. Sie durchbrechen wichtige Prinzipien der objektorientierten Programmierung.
				\end{compactitem}					
					
		\subsubsection{Beispiel an der Klasse Rechteck}
			\begin{minipage}[t]{9cm}
				\vspace*{-0.5cm}\lstinputlisting[language=C++,tabsize=2]{code/class_rectangle_header.cpp}
				\begin{center}			
					\begin{tikzpicture}
						\begin{class}[text width=5cm]{Rectangle}{0 ,0}
							\attribute{-a : double}
							\attribute{-b : double}
							\operation{+setA(in newA : double)}
							\operation{+setB(in newB : double)}
							\operation{+getA() : double}
							\operation{+getB() : double}
							\operation{+getArea() : double}
						\end{class}
					\end{tikzpicture}
				\end{center}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9 cm}
				\vspace*{-0.5cm}\lstinputlisting[language=C++,tabsize=2]{code/class_rectangle.cpp} 
			\end{minipage} \\
			
	\begin{minipage}[t]{8cm}
		\subsection{Elementfunktionen}
			\begin{compactitem}
				\item sind Funktionen, die in der Schnittstelle der Klasse spezifiziert sind.
				\item Elementfunktionen haben vollen Zugriff auf alle Klassenelemente (auch auf
				solche, die mit \lc{private:} gekennzeichnet sind.
				\item Auf Elementfunktionen kann nur unter Bezugnahme auf ein Objekt der Klasse, bzw. mit dem Scope-Operator (\lc{::}) zugegriffen werden.
				\item Elementfunktionen sollen prinzipiell in der Implementierungsdatei (\lc{.cpp}) implementiert werden. Dem Funktionsnamen muss dabei der Klassenname gefolgt von \lc{::} vorangestellt werden. (Beispiel: \lc{int Stack::pop()})
			\end{compactitem}
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{10 cm}
			\subsubsection{Klassifizierung von Elementfunktionen}
				\begin{compactitem}
					\item Konstruktoren / Destruktoren
						\begin{compactitem}
							\item Konstruktor: erzeugen eines Objekts
							\item Destruktur: vernichten, freigeben eines Objekts
						\end{compactitem}
					\item Modifikatoren
						\begin{compactitem}
							\item ändern den Zustand eines Objekts (Attribute ändern)
						\end{compactitem}
					\item Selektoren
						\begin{compactitem}
							\item greifen nur lesend auf ein Objekt zu (immer \lc{const} definieren!)
							\item Beispiel: \lc{bool Stack::isEmpty() const;}
						\end{compactitem}
					\item Iteratoren
						\begin{compactitem}
							\item Erlauben, auf Elemente eines Objekts in einer definierten Reihenfolge	zuzugreifen
						\end{compactitem}
				\end{compactitem}
	\end{minipage} \\
	
			\subsubsection{$inline$-Funktionen}
				\begin{compactitem}
					\item Elementfunktionen, die innerhalb der Deklaration der Klassenschnittstelle (im \lc{.h}-File) implementiert sind, werden als (implizite) \lc{inline} - Funktionen
					behandelt.
					\item Implizite \lc{inline} - Funktionen verletzen zwar das Information Hiding Prinzip	und sollten deshalb grundsätzlich vermieden werden.
					\item Jedoch: die impliziten \lc{inline} - Funktionen sind die Funktionen, die garantiert immer \lc{inline} verwendet werden (mit einigen wenigen
					Ausnahmen).
					\item Elementfunktionen können in der Klassenimplementation explizit mit dem Schlüsselwort \lc{inline} gekennzeichnet werden.
				\end{compactitem}	
		
	\vspace*{-1cm}\begin{minipage}[t]{7cm}
			\subsubsection{mutable - Attribut}
				Ein Datenelement, das nie \lc{const} werden soll (auch nicht bei \lc{const}-Elementfunktionen) kann mit \lc{mutable} gekennzeichnet werden.
				\lstinputlisting[language=C++,tabsize=2]{code/mutable.cpp}		
	\end{minipage}
	\hspace*{0.5cm}
	\begin{minipage}[t]{11 cm}			
			\subsubsection{const - Elementfunktion}
				\begin{compactitem}
					\item Elementfunktionen, die den Zustand eines Objekts nicht ändern (Selektoren)
					sollen explizit mit dem Schlüsselwort \lc{const} gekennzeichnet werden.
					\item Das Schlüsselwort \lc{const} muss sowohl im Prototypen als auch in der
					Implementierung geschrieben werden.
				\end{compactitem}
				\lstinputlisting[language=C++,tabsize=2]{code/elementfunktion_const.cpp}
				
		\subsection{static - Klassenelemente}
			\begin{compactitem}
				\item Grundsätzlich besitzt jedes Objekt einer Klasse seine eigene private Instanz
				aller Attribute einer Klasse.
				\item Wenn ein Attribut mit \lc{static} gekennzeichnet wird, dann teilen sich alle
				Objekte dieser Klasse eine einzige Instanz dieses Attributs, d.h. ein
				statisches Attribut ist nur einmal für alle Objekte einer Klasse im Speicher
				vorhanden.
				\item \lc{static} - Elemente befinden sich ausserhalb eines Objektkontexts.
				\item \lc{static} - Elemente können auch über den Klassennamen angesprochen
				werden (da sie sich im Kontext einer Klasse befinden).
			\end{compactitem}	
	\end{minipage}
			
	\subsection{$this$ - Pointer}
		Der \lc{this}-Pointer ist ein Pointer auf das eigene aktuelle Objekt, welches eine Methode aufgerufen hat.
		\lstinputlisting[language=C++,tabsize=2]{code/this_pointer.cpp}
	
	\subsection{Konstruktor (am Beispiel der Klasse TString)}
		\begin{minipage}[t]{9cm}
			\subsubsection{Aufgaben des Konstruktors}
				\begin{compactitem}
					\item die Neugründung eines Objekts einer Klasse
					\item das saubere Initialisieren des Objekts, d.h. alle Attribute des Objekts
					müssen auf einen definierten Wert gesetzt werden
					\item Der Konstruktor hat in \lc{C++} denselben Namen wie die Klasse, hat keinen
					Rückgabetyp (auch nicht \lc{void}) und kann überladen werden. Beispiel: \lc{Stack::Stack();}
				\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9cm}
			\subsubsection{Aufruf des Konstuktors}
				\begin{compactitem}
					\item Der Konstruktor soll nie explizit aufgerufen werden.
					\item Der Konstruktor wird vom System automatisch (implizit) aufgerufen, wenn
					ein Objekt erzeugt wird: \lc{Stack s;}
					\item Wenn durch den \lc{new}-Operator Speicher angefordert {\bf und} erhalten wird, dann wird der Konstruktor vom System ebenfalls automatisch aufgerufen: \\ \lc{Stack* pS = new Stack;}
				\end{compactitem}	
		\end{minipage} 
		
		\subsubsection{Default-Konstruktor}
			\begin{minipage}[t]{13cm}
				\begin{compactitem}
					\item Der Default-Konstruktor ist der Konstruktor ohne Parameter.
					\item Er wird vom System automatisch erzeugt, wenn für
					eine Klasse kein Konstruktor explizit definiert ist.
					\item Der Default-Konstruktor kann auch selbst definiert werden.
					\begin{compactitem}
						\item Das ist insbesondere dann notwendig, wenn innerhalb des Objekts Speicher
						dynamisch alloziert werden muss (bei der Objekterzeugung).
					\end{compactitem}
				\end{compactitem}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{5cm}
				\vspace*{-0.5cm}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_default.cpp}
			\end{minipage}
			
		\subsubsection{Implementation/Initialisierung}
			Die Definition der Attribute muss der Reihe nach erfolgen, so wie im Headerfile. Dabei gibt es die folgenden zwei Möglichkeiten:
			\begin{minipage}[t]{9cm}
				\paragraph{mittels Anweisung}
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_init_default.cpp}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9cm}
				\paragraph{mittels Initialisierungsliste}
					\lstinputlisting[language=C++,tabsize=2]{code/constructor_init_list.cpp}
			\end{minipage} \\
			Objektinitialisierungen werden, sofern dies möglich ist, über die Initialisierungsliste des Konstruktors und nicht im Anweisungsteil durchgeführt. (Effizienzgründe) \\
			
		\subsubsection{Überladen von Konstruktoren}
			\begin{minipage}[t]{12cm}
				\textbf{Objekterzeugung:}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_overload.cpp}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{6cm}
				\textbf{Deklaration:}
				\lstinputlisting[language=C++,tabsize=2]{code/constructor_overload_implement.cpp}
			\end{minipage}
			
		\subsubsection{Konstruktoren und Function Casts}
			Bei nur einem Parameter kann ein Konstruktor auch zur Typumwandlung benutzt werden (explicit call).
			
		\subsubsection{Explizite Konstruktoren}
			\begin{minipage}[t]{12cm}
				Falls das implizite Aufrufen eines Konstruktors nicht erwünscht ist, kann er mit $explicit$ gekennzeichnet werden. Damit kann dieser Konstruktor nicht mehr implizit, sondern nur explizit aufgerufen werden.
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{6cm}
					\lstinputlisting{code/constructor_explicit.cpp}
			\end{minipage}
			
		\subsubsection{Copy-Konstruktor}
			\begin{compactitem}
				\item Der Copy-Konstruktor wird dazu verwendet, Objekte zu kopieren.
				\item Er erhält als Parameter immer eine konstante Referenz auf
				ein Objekt der Klasse.
				\item Wenn ein Objekt Speicher auf dem Heap alloziert, muss ein eigener Copy-Konstruktor definiert werden.
			\end{compactitem}
			Der Copy-Konstruktor wird automatisch aufgerufen, wenn ...
			\begin{compactitem}
				\item ... ein Objekt mit einem anderen Objekt derselben Klasse initialisiert wird.
				\item ... ein Objekt als Wertparameter (by value) an eine Funktion übergeben wird
				(nicht aber bei Referenzparametern).
				\item ... ein Objekt by value als Resultat einer Funktion zurückgegeben wird (nicht bei Referenzrückgabewerten).
			\end{compactitem}
			Folgend ein Beispiel, wie ein eigener C-tor im Headerfile implementiert wird:
			\lstinputlisting{code/constructor_copy.cpp}
			
			\paragraph{Shallow Copy vs. Deep Copy}
				\begin{compactitem}
					\item Wenn für eine Klasse kein Copy-Konstruktor definiert wird, erzeugt das System einen Standard-Copy-Konstruktor.
					\item Dieser kopiert alle Datenelemente (memberwise assignment). Bei Pointern, welche auf den Heap zeigen, wird nur die Adresse kopiert, nicht aber der Speicher auf dem Heap. Man nennt das shallow copy. (shallow = flach).
					\item Bei einer deep copy werden auch die Speicherbereiche, auf welche die Pointer zeigen, kopiert. Diese deep copy muss in einem selbst definierten Copy-Konstruktor implementiert werden.
				\end{compactitem}
			
			\begin{minipage}[t]{9cm}
				\vspace*{-0.3cm}\paragraph{Shallow-Copy}
					\vspace*{-0.3cm}\includegraphics[width=1\textwidth]{pics/shallow_copy.jpg}
			\end{minipage}
			\hspace*{0.5cm}
			\begin{minipage}[t]{9cm}
				\vspace*{-0.3cm}\paragraph{Deep-Copy}
					\vspace*{-0.3cm}\includegraphics[width=1\textwidth]{pics/deep_copy.jpg}
			\end{minipage}
			
	\vspace*{-0.1cm}\subsection{Destruktor}
		\begin{compactitem}
			\item Vollständige und "saubere" Zerstörung eines nicht mehr benötigten Objekts
			\item Sie werden automatisch aufgerufen, wenn der Gültigkeitsbereich des definierten Objekts ausläuft
			\item Die häuftigste Aufgabe ist die Freigabe von nicht mehr benötigten Speicher auf dem Heap
			\item sehr häufig (Wenn kein Speicher auf dem Heap vorhanden ist) wird kein Destruktor definiert, da das System dann automatisch aufräumt
			\item Destruktoren haben keine Argumente und keine Rückgabetypen
			\item Die Reihenfolge des Aufrufs der Destruktoren ist umgekehrt wie die der Konstruktoren. (das zuletzt erzeugte Objekt wird zuerst aufgeräumt)
			\item sobald eine Methode mit $virtual$ gekennzeichnet ist, muss der Destruktor auch virtual sein.
		\end{compactitem}
		Folgend ein Beispiel, wie ein eigener D-tor im Headerfile implementiert wird:
		\lstinputlisting{code/destructor_bsp.cpp}
	
	\subsection{Member In-Class Initialization}
		\begin{minipage}[t]{9cm}
			\begin{compactitem}
				\item Ab $C++11$ können bei der Klassendeklaration den Attributen Initialisierungswerte zugewiesen werden.
				\item Implementationstechnisch sind sie äquivalent zur Initialisierungsliste bei C-tors
			\end{compactitem}
		\end{minipage}
		\hspace*{0.5cm}
		\begin{minipage}[t]{9cm}
			\vspace*{-0.8cm}\lstinputlisting{code/member_in_class_init.cpp}
		\end{minipage}
	
	\vspace*{-0.3cm}
	\subsection{kanonische Form von Klassen}
		\begin{compactitem}
			\item Die kanonische Form ist die Form, die es erlaubt, eine Klasse wie einen «normalen» Datentyp zu benutzen (ist für alle Klassen anzustreben).
			\item 3 Bedingungen:
			\begin{compactenum}
				\item Ein korrekter Default-Konstruktor, plus evtl. weitere Konstruktoren
				\item Bei dynamischen Daten, braucht es einen Zuweisungsoperator (später) und einen Copy-Konstruktor
				\item Ein (virtueller) Destruktor garantiert die korrekte Zerstörung von Objekten
			\end{compactenum} 
		\end{compactitem}
		
	\subsection{Unions}
		\begin{compactitem}
			\item ähnlich wie Struktur
			\item im Gegensatz zur Struktur ist aber nur ein einziges Feld jeweils aktiv (abhängig vom Typ)
			\item Die Grösse einer Union ist so gross wie das grösste Feld der Union
			\item {\bf Vorsicht}, der Programmierer muss verfolgen, welcher Typ jeweils in der Union gespeichert ist. Der Datentyp, der entnommen wird, muss der sein, der zuletzt gespeichert wurde. 
		\end{compactitem}
		\begin{minipage}[t]{5 cm}
			\subsubsection{Beispiel}
				\vspace*{-0.3cm}
				\lstinputlisting{code/unions2.c}
		\end{minipage}
		\hspace*{0.5cm}	
		\begin{minipage}[t]{4.5 cm}
			\vspace*{0.1cm}\includegraphics[width=\textwidth]{pics/union.png}
		\end{minipage}

	\subsection{Bitfelder}
		\begin{compactitem}
			\item Innerhalb eines int?s können einzelne Bitgruppen definiert und angesprochen werden
			\item Kann nützlich sein, wenn auf einzelne Bitgruppen in einem Register zugegriffen werden soll
			\item {\bf Achtung:} ist nicht definiert, ob die Bits von links oder von rechts aufgefüllt werden (Compilerabhängig)
			\item Sollte also nicht eingesetzt werden, wenn der Code portabel sein soll
			\item Der Datentyp eines Bits ist immer derselbe, wie das ganze Bitfeld gross ist
		\end{compactitem}
		\lstinputlisting{code/bitfeld.cpp}
	
	\subsection{Überladen von Operatoren}
		Operatoren (z.B. +, ==, etc.) können wie Funktionen überladen werden.
		
		\subsubsection{Überladbare Operatorfunktionen in C++}
		\begin{minipage}[t]{3 cm}
			\begin{compactitem}
				\item \lc{new}
				\item \lc{delete}				
				\item \lc{new[ ]}				
				\item \lc{delete[ ]} 	
				\item \lc{+}
				\item \lc{-}							
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem}	
				\item \lc{*}
				\item \lc{/}			
				\item \lc{\%}
				\item \lc{\textasciicircum}
				\item \lc{\&}	
				\item \lc{|}		
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem}	
				\item \lc{\textasciitilde}
				\item \lc{!}	
				\item \lc{=} 			 	
				\item \lc{<} 	
				\item \lc{>}	 		 	
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem}	
				\item \lc{+=}			 	
				\item \lc{-=}			 	
				\item \lc{*=}		
				\item \lc{/=}	
				\item \lc{\%=}		 	
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem} 
				\item \lc{\textasciicircum=}			 	
				\item \lc{\&=} 		 	
				\item \lc{|=}			 	
				\item \lc{<<}		
				\item \lc{>>}	 	
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem}		 
				\item \lc{>>=} 			 	
				\item \lc{<<=}			 	
				\item \lc{==} 			 	
				\item \lc{!=}
				\item \lc{<=}	
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.1 cm}
			\begin{compactitem}		 	
				\item \lc{>=} 		 	
				\item \lc{\&\&} 			 	
				\item \lc{||} 			 	
				\item \lc{++} 		
				\item \lc{--}	 	
			\end{compactitem}
		\end{minipage}
		\begin{minipage}[t]{2.4 cm}
			\begin{compactitem}		 	
				\item \lc{,} 			 	
				\item \lc{->*}	
				\item \lc{->}		 	
				\item \lc{()}
				\item \lc{[ ]}
			\end{compactitem}
		\end{minipage}
		
		\subsubsection{Randbedingungen}
		\begin{compactitem}
			\item Die Anzahl der Operanden (Argumente) muss gleich sein wie beim ursprünglichen Operator.
			\item Die Priorität des überladenen Operators kann nicht ändern.
			\item Neue Operatoren können nicht eingeführt werden.
			\item Default-Argumente sind bei Operatoren nicht möglich.
		\end{compactitem}
	
		\subsubsection{Operator Overloading als Elementfunktion}
		Der neu definierte Operator wird als Elementfunktion implementiert. Damit ist
		der Zugriff auf \lc{private} und \lc{protected} Attribute der Klasse möglich.
		\lstinputlisting{code/operator_overloading_element.cpp}
		{\bf Achtung:} Zwingend als Elementfunktion zu implementieren sind: \\
		Zuweisungsoperator \lc{=}, Indexaufruf \lc{[ ]}, Funktionsaufruf \lc{()} und Zeigeroperator \lc{->}
		
		\subsubsection{Operator Overloading als normale Funktion}
		Die Operatorfunktionen werden meist als normale Funktion implementiert. Dadurch besteht jedoch kein Zugriff mehr auf die \lc{private} und \lc{protected} Elemente der Klasse. Die Operatorfunktion muss deshalb als \lc{friend} deklariert werden.
		\lstinputlisting{code/operator_overloading_normal.cpp}
		